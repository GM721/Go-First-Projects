package storage

import (
	"Order/entities"
	"database/sql"
	"errors"
	"fmt"

	_ "github.com/lib/pq"
)

type StorageOrder struct {
	DB *sql.DB
}

func New(storagePath string) (*StorageOrder, error) {
	const op = "storage.New"

	db, err := sql.Open("postgres", storagePath)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", op, err)
	}
	rows, err := db.Query("SELECT * FROM information_schema.tables WHERE table_name='orders'")
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	if !rows.Next() {
		_, err := db.Exec("CREATE TYPE status AS ENUM ('CREATED', 'PAID', 'CANCELED')")
		if err != nil {
			panic(err)
		}

		_, err = db.Exec("create table orders (ID integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, ClientID integer, Amount float,Status status)")
		if err != nil {
			panic(err)
		}

	}
	return &StorageOrder{DB: db}, nil
}

func (storage *StorageOrder) AddNewOrder(order *entities.Order) (*entities.Order, error) {
	err := storage.DB.QueryRow("insert into orders (clientid, amount, status) values ($1, $2, $3) RETURNING ID", order.ClientID, order.Amount, order.Status).Scan(&order.ID)
	if err != nil {
		return nil, errors.New("CANT CREATE ORDER")
	}
	return order, nil
}

func (storage *StorageOrder) GetOrderById(id uint) (*entities.Order, error) {

	var order = &entities.Order{}
	rows, err := storage.DB.Query("select * from orders where id = $1", id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	rows.Next()
	err = rows.Scan(&order.ID, &order.ClientID, &order.Amount, &order.Status)
	if err != nil {
		return nil, err
	}
	return order, nil
}

func (storage *StorageOrder) UpdateStatus(order *entities.Order) error {
	_, err := storage.DB.Exec("update orders set status = $1 where id = $2", order.Status, order.ID)
	if err != nil {
		return errors.New("CANT SET STATUS")
	}
	return nil
}
